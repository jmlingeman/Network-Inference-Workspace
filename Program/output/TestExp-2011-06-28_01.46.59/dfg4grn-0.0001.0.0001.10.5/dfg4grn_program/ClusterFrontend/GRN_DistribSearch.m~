%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GRN_DistribSearch
% This file contains the frontend to perform the distributed search
% to find good hyperparameter's for Piotr's state space algorithm.
% Currently, this code only supports a basic grid search, but other
% algorithms such as Simulated Annealing are planned.
% This file also contains the necessary methods to evaluate the output
% models.
% 
% Params:
%   out_dir - this is what to call the test.  The results will be
%              saved in a folder with this name.
%   num_models - this is the number of models to run per hyperparamter
%                selection.  This should be between 20 and 100.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
function GRN_DistribSearch(out_dir, script_name, num_models, ...
  meas_name, par1, var1range, par2, var2range, par3, var3range)

 
% Parameters
% ----------

% Number of times to run each hyperparameter combination
% so we can average across them.
if (nargin < 3)
  num_models = 20;
end
if (nargin < 4)
  meas_name = 'error_trend_r2';
end
if (nargin < 6)
  par1 = 'gamma';
  var1range = [0.01 0.05 0.1 0.5 1];
end
if (nargin < 8)
  par2 = '';
  var2range = [];
end
if (nargin < 10)
  par3 = '';
  var3range = [];
end

date_string = datestr(clock, 'yyyy-mm-dd_HH-MM-ss');


% Hyperparameter selection
% ------------------------
 
% Coarse grid search
fprintf(1, 'GRN: optimize %s %s %s on coarse grid...\n', par1, par2, par3);
out_coarse = strcat(out_dir, '_', date_string, '_coarse');
[best_meas_coarse, ...
  best_val1_coarse, best_val2_coarse, best_val3_coarse] = ...
  GridSearch(script_name, out_coarse, num_models, meas_name, ...
  par1, var1range, par2, var2range, par3, var3range);
    
fprintf(1, 'GRN: best %s=%g for %s=%g', ...
  meas_name, best_meas_coarse, par1, best_val1_coarse);
if ~isempty(par2)
  fprintf(1, ', %s=%g', par2, best_val2_coarse);
end
if ~isempty(par3)
  fprintf(1, ', %s=%g', par3, best_val3_coarse);
end
fprintf(1, '\n');

% Refine the coarse grids
var1range = RefineGrid(var1range, best_val1_coarse);
if ~isempty(par2)
  var2range = RefineGrid(var2range, best_val2_coarse);
end
if ~isempty(par3)
  var3range = RefineGrid(var3range, best_val3_coarse);
end

% Fine grid search
fprintf(1, 'GRN: optimize %s %s %s on fine grid...\n', par1, par2, par3);
out_fine = strcat(out_dir, '_', date_string, '_fine');
[best_meas_fine, ...
  best_val1_fine, best_val2_fine, best_val3_fine] = ...
  GridSearch(script_name, out_fine, num_models, meas_name, ...
  par1, var1range, par2, var2range, par3, var3range);

fprintf(1, 'GRN: best %s=%g for %s=%g', ...
  meas_name, best_meas_fine, par1, best_val1_fine);
if ~isempty(par2)
  fprintf(1, ', %s=%g', par2, best_val2_fine);
end
if ~isempty(par3)
  fprintf(1, ', %s=%g', par3, best_val3_fine);
end
fprintf(1, '\n');


exit
end


% -------------------------------------------------------------------------
% Code to evaluate the models generated by grid search.  Assume that they
% were saved in a directory in the out_dir dir with the same name as out_dir
% and are numbered sequentially.
% Given a file that contains N number of models, go through them extracting
% the best epoch.  Then average that epoch with the best epoch from the
% other models.
% -------------------------------------------------------------------------
function [best_meas, best_val1, best_val2, best_val3] = ...
  EvalModels(out_dir, meas_name, par1, par2, par3)

% Get the list of Matlab files
files = dir([out_dir '/*.mat']);

% Inspect all results
best_meas = -inf;
best_val1 = -inf;
best_val2 = -inf;
best_val3 = -inf;
for i = 1:length(files)
  % Get the MODEL and METER_INFER_TEST variables from file <i>
  d = load(sprintf('%s/%s', out_dir, files(i).name));

  % Evaluate measure
  meas = eval(['d.METER_INFER_TEST{end}.last_' meas_name ';']);
  if (meas > best_meas)
    best_meas = meas;

    % Evaluate first parameter
    best_val1 = eval(['d.params.' par1 ';']);

    % Evaluate second parameter?
    if ~isempty(par2)
      best_val2 = eval(['d.params.' par2 ';']);
    end

    % Evaluate third parameter?
    if ~isempty(par3)
      best_val3 = eval(['d.params.' par3 ';']);
    end
  end
end
 
end


% -------------------------------------------------------------------------
% Grid search code.  This code will generate and start the hyperparameter
% selections on SGE.
% ------------------------------------------------------------------------
function [best_meas, best_val1, best_val2, best_val3] = ...
  GridSearch(script_name, out_dir, num_models, meas_name, ...
  par1, var1range, par2, var2range, par3, var3range)


% Paths
% shell_script = 'grn_debug_submit.sh';
shell_script = 'grn_submit.sh';
path_to_scripts = which('GRN_DistribSearch');
idx = strfind(path_to_scripts,'/');
path_to_scripts = path_to_scripts(1:idx(length(idx))-1);

mkdir(out_dir);

% Loop over the first parameter
jobs_count = 0;
for i = 1:length(var1range)
  val1 = var1range(i);

  % Is there a second parameter?
  if ~isempty(par2)

    % Grid search on a second parameter
    for j = 1:length(var2range)
      val2 = var2range(j);

      % Is there a third parameter?
      if ~isempty(par3)

        % Grid search on a third parameter
        for k = 1:length(var3range)
          val3 = var3range(k);
        
          fprintf(1, 'GRN: Testing %s=%g, %s=%g, %s=%g, %g times...\n', ...
            par1, val1, par2, val2, par3, val3, num_models);
          out_file = sprintf('%s/%s%g_%s%g_%s%g.mat', ...
            out_dir, par1, val1, par2, val2, par3, val3);
          command = sprintf('%s/%s %s %s %s %d %s %g %s %g %s %g', ...
            path_to_scripts, shell_script, path_to_scripts, ...
            script_name, out_file, num_models, ...
            par1, val1, par2, val2, par3, val3);
          system(command);
          jobs_count = jobs_count + 1;
        end
      else

        % No third parameter
        fprintf(1, 'GRN: Testing %s=%g, %s=%g, %g times...\n', ...
          par1, val1, par2, val2, num_models);
        out_file = sprintf('%s/%s%g_%s%g.mat', ...
          out_dir, par1, val1, par2, val2);
        command = sprintf('%s/%s %s %s %s %d %s %g %s %g', ...
          path_to_scripts, shell_script, path_to_scripts, ...
          script_name, out_file, num_models, par1, val1, par2, val2);
        system(command);
        jobs_count = jobs_count + 1;
      end
    end
  else

    % No second nor third parameter
    fprintf(1, 'GRN: Testing %s=%g %g times...\n', par1, val1, num_models);
    out_file = sprintf('%s/%s%g.mat', out_dir, par1, val1);
    command = sprintf('%s/%s %s %s %s %d %s %g', ...
      path_to_scripts, shell_script, path_to_scripts, ...
      script_name, out_file, num_models, par1, val1);
    system(command);
    jobs_count = jobs_count + 1;
  end
end

% Wait for the jobs to complete
fprintf(1, 'Waiting for worker functions to return...\n');
jobs_completed = (length(dir([out_dir '/*.mat'])));
while (jobs_completed < jobs_count)
  % When counting the jobs, include the .txt file
  jobs_completed = (length(dir([out_dir '/*.mat'])));
  fprintf(1,'%3g out of %3g have returned...\n', ...
    jobs_completed, jobs_count);
  pause(5)
end
fprintf(1,'SUCCESS: all %g jobs have returned...\n', jobs_completed);

% Evaluate the jobs
[best_meas, best_val1, best_val2, best_val3] = ...
  EvalModels(out_dir, meas_name, par1, par2, par3);

fprintf(1, 'Best %s=%g at %s=%g', meas_name, best_meas, par1, best_val1);
if ~isempty(par2)
  fprintf(1, ', %s=%g', par2, best_val2);
end
if ~isempty(par3)
  fprintf(1, ', %s=%g', par3, best_val3);
end
fprintf(1, '\n');

end


%--------------------------------------------------------------------------
% Refine a grid around the best value.
%--------------------------------------------------------------------------
function varRange = RefineGrid(varRange, best_val)

% Find the matching value of the parameter
[dummy, ind] = find(varRange == best_val);

% Select "neighbors"
n = length(varRange);
if (ind == 1)
  indNeighbors = [1, min(n, 3)];
elseif (ind == n)
  indNeighbors = [max(1, n-2), n];
else
  indNeighbors = [max(1, ind-2), min(n, ind+2)];
end

% Interpolate linearly 10 parameter values
val1 = varRange(indNeighbors(1));
val2 = varRange(indNeighbors(2));
varRange = linspace(val1, val2, 10);

end


%--------------------------------------------------------------------------
% Simulated annealing algorithm.  The goal of this is to try to use SA to
% find out optimal hyperparameters as an alternative to GridSearch.
%--------------------------------------------------------------------------
function [best_meas, best_val1, best_val2, best_val3] = ...
  SimulatedAnnealing(script_name, out_dir, num_models, meas_name, ...
  par1, var1range, par2, var2range, par3, var3range)

error('TODO');

end

%-------------------------------------------------------------------------
% Genetic Alg CMA-ES
%-------------------------------------------------------------------------

function xmin=purecmaes   % (mu/mu_w, lambda)-CMA-ES 
 
  % --------------------  Initialization --------------------------------  
  % User defined input parameters (need to be edited)
  strfitnessfct = 'GRN_Batch_AR1';  % name of objective/fitness function
  N = 1;               % number of objective variables/problem dimension
  xmean = rand(N,1);    % objective variables initial point
  sigma = 0.5;          % coordinate wise standard deviation (step size)
  stopfitness = 1e-10;  % stop if fitness < stopfitness (minimization)
  stopeval = 1e3*N^2;   % stop after stopeval number of function evaluations
 
  % Strategy parameter setting: Selection  
  lambda = 4+floor(3*log(N));  % population size, offspring number
  mu = lambda/2;               % number of parents/points for recombination
  weights = log(mu+1/2)-log(1:mu)'; % muXone array for weighted recombination
  mu = floor(mu);        
  weights = weights/sum(weights);     % normalize recombination weights array
  mueff=sum(weights)^2/sum(weights.^2); % variance-effectiveness of sum w_i x_i
 
  % Strategy parameter setting: Adaptation
  cc = (4+mueff/N) / (N+4 + 2*mueff/N);  % time constant for cumulation for C
  cs = (mueff+2) / (N+mueff+5);  % t-const for cumulation for sigma control
  c1 = 2 / ((N+1.3)^2+mueff);    % learning rate for rank-one update of C
  cmu = 2 * (mueff-2+1/mueff) / ((N+2)^2+mueff);  % and for rank-mu update
  damps = 1 + 2*max(0, sqrt((mueff-1)/(N+1))-1) + cs; % damping for sigma 
                                                      % usually close to 1
  % Initialize dynamic (internal) strategy parameters and constants
  pc = zeros(N,1); ps = zeros(N,1);   % evolution paths for C and sigma
  B = eye(N,N);                       % B defines the coordinate system
  D = ones(N,1);                      % diagonal D defines the scaling
  C = B * diag(D.^2) * B';            % covariance matrix C
  invsqrtC = B * diag(D.^-1) * B';    % C^-1/2 
  eigeneval = 0;                      % track update of B and D
  chiN=N^0.5*(1-1/(4*N)+1/(21*N^2));  % expectation of 
                                      %   ||N(0,I)|| == norm(randn(N,1))
 
  % -------------------- Generation Loop --------------------------------
  counteval = 0;  % the next 40 lines contain the 20 lines of interesting code 
  while counteval < stopeval
 
      % Generate and evaluate lambda offspring
      for k=1:lambda,
          arx(:,k) = xmean + sigma * B * (D .* randn(N,1)); % m + sig * Normal(0,C) 
          arfitness(k) = feval(strfitnessfct, arx(:,k)); % objective function call
          counteval = counteval+1;
      end
 
      % Sort by fitness and compute weighted mean into xmean
      [arfitness, arindex] = sort(arfitness); % minimization
      xold = xmean;
      xmean = arx(:,arindex(1:mu))*weights;   % recombination, new mean value
 
      % Cumulation: Update evolution paths
      ps = (1-cs)*ps ... 
            + sqrt(cs*(2-cs)*mueff) * invsqrtC * (xmean-xold) / sigma; 
      hsig = norm(ps)/sqrt(1-(1-cs)^(2*counteval/lambda))/chiN < 1.4 + 2/(N+1);
      pc = (1-cc)*pc ...
            + hsig * sqrt(cc*(2-cc)*mueff) * (xmean-xold) / sigma; 
 
      % Adapt covariance matrix C
      artmp = (1/sigma) * (arx(:,arindex(1:mu))-repmat(xold,1,mu));
      C = (1-c1-cmu) * C ...                  % regard old matrix  
           + c1 * (pc*pc' ...                 % plus rank one update
                   + (1-hsig) * cc*(2-cc) * C) ... % minor correction if hsig==0
           + cmu * artmp * diag(weights) * artmp'; % plus rank mu update 
 
      % Adapt step size sigma
      sigma = sigma * exp((cs/damps)*(norm(ps)/chiN - 1)); 
 
      % Decomposition of C into B*diag(D.^2)*B' (diagonalization)
      if counteval - eigeneval > lambda/(c1+cmu)/N/10  % to achieve O(N^2)
          eigeneval = counteval;
          C = triu(C) + triu(C,1)'; % enforce symmetry
          [B,D] = eig(C);           % eigen decomposition, B==normalized eigenvectors
          D = sqrt(diag(D));        % D is a vector of standard deviations now
          invsqrtC = B * diag(D.^-1) * B';
      end
 
      % Break, if fitness is good enough or condition exceeds 1e14, better termination methods are advisable 
      if arfitness(1) <= stopfitness || max(D) > 1e7 * min(D)
          break;
      end
 
  end % while, end generation loop
 
  xmin = arx(:, arindex(1)); % Return best point of last iteration.
                             % Notice that xmean is expected to be even
                             % better.
end
 
% ---------------------------------------------------------------  